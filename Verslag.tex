\documentclass{article}
\usepackage[left=3cm, right=3cm, top=3cm, bottom=3cm]{geometry}
\usepackage{pdfpages}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{ {figures/} }
\usepackage{array}

\begin{document}

\includepdf[pages=-]{frontpage.pdf}

\section*{Abstract}
\thispagestyle{empty}

\newpage
\tableofcontents
\thispagestyle{empty}

\newpage
\listoftables
\thispagestyle{empty}

\newpage
\listoffigures
\thispagestyle{empty}

\newpage
\section{Introduction}
\pagenumbering{arabic}

\section{Description of the problem}

\hspace{\parindent} Given is a basket with a standard rectangular shape with fixed dimensions. The objective is to count every object in this basket. If possible, the objects can be outlined by the system.\\

\noindent The system used should be based on color and depth images.


\section{Design and implementation}
\subsection{Hardware}
\subsection{Software}
\subsubsection{RGB sensor}

There are a lot of options when it comes to software and there exist many different algorithms for image processing. The diagram on FIG…XX… shows a couple of different methods. There is no ‘right-way’ to count objects in an image. Different methods have different advantages and disadvantages. The only things that appears in almost all algorithms are:
-	Converting the RGB image to grayscale
-	Run filters over the image to remove noise
These things are also visible in the diagram.
\paragraph{Method 1}
This method is the most simple and easy to write. It starts with the grayscale image which has been filtered. Then it runs an thresholding-algorithm with a pre-defined threshold value over the image and the output is a binary image. That’s an image that only has 0’s and 1’s in his matrix.  It’s also possible to use an algorithm to search for the best threshold value.  After that there is a simple edge detection algorithm which makes the edges visible. 
Advantages: it’s an easy and fast algorithm.
Disadvantages: with a pre-defined threshold value it just classifies pixels based on colour. 
\paragraph{Method 2}
Method 2 is the reverse of method 1: it starts with an edge detection algorithm. But a different one than in method 1 and a bit more complicated. This algorithm gives back an greyscale image, not a binary image. After that is a threshold algorithm with a pre-defined threshold value and the edges are converted to a binary image. Because there is a lot of noise with this method, it's recommended to use a noise reduction algorithm. 
Advantages: it detects all kind of objects, not based on colour or shape.
Disadvantages: the boundary between different objects needs to be clear.
\paragraph{Method 3}
This method is different. It makes a compromise in functionality: it needs a picture of the background alone before it can detect objects. First it loads an background image, converts it to grayscale and runs some filters over the image. After that, the algorithm loops through the image pixel by pixel, checks if the pixel on the image is within a certain range of the same pixel on the background image. If the pixel is within that range, that pixel gets classified as background. The output is a binary image with only the objects.  
Advantages: it is better in detecting objects, not based on colour or shape.
Disadvantages: There needs to be an image of the empty background, and lightning conditions etc. can’t change.

\paragraph{Implementation}
After a lot of testing different methods, the three methods above seemed the most interesting. After comparing these methods with each other, it seems that method 2 is the best choice. See figure XXXX for the comparison.

As mentioned above, the fist thing that needs to be done with the image is converting it to grayscale. An RGB image exists from colors: red, green and blue. Thus an RGB image is a 3-dimensional matrix. The grayscale image is calculated by multiplying the individual color values with a color-specific weight. So loop through every pixel and combine the 3-dimensional RGB matrix to a 1-dimensional grayscale image.

grayscale_image(row, col) = 0.2989 * RED + 0.5870 * GREEN + 0.1140 * BLUE;  

All the weights count up to 1 so the values in the grayscale image can vary from 0 to 255.

This method uses two filters to remove noise from the image. 
Figure XXXX shows why those two filters are necessary.

At first the gaussian blur, this is an easy convolution on the image matrix.
G = (1/159) * \[
\begin{bmatrix}
    2 & 4 & 5 & 4 & 2\\
    4 & 9 & 12 & 9 &4\\
    5 & 12 &15&12&5\\
    4&9&12&9&4\\
    2&4&5&4&2
\end{bmatrix}
\]

The blur can be applied by doing a convolution of the G matrix on the image matrix.

The second blur is a mean blur. This is another matrix to do the convolution with.

M = (1/9) * \[
\begin{bmatrix}
	1&1&1\\
	1&1&1\\
	1&1&1
\end{bmatrix}
\]

Then comes the edge detection algorithm, this is also just a matrix to do the convolution with.
(!! meer info!!)
L = \[
\begin{bmatrix}
	0&-1&0\\
	-1&4&-1\\
	0&-1&0
\end{bmatrix}
\]

\subsubsection{Depth sensor}

\section{Budget management}

\section{course integration}

\section{Conclusion}

\section{List of references}

\section{Appendix}

\end{document}
